Все что за \\ мои комментарии того, что написано в методичке

first:
1. Если х - терминал, то first(x)={x}. \\ и так все понятно
2. Если в грамматике присутствует правило Х-> э, то множество first(х) включает э. Это означает, что Х может начинаться с пустой последовательности, то есть отсутствовать вообще. \\ То есть если последовательность продуцируется в эпсилон, то соответсвенно она с эпсилона может начинаться
3. Для всех продукций вида X->Y1 Y2 … Yk выполняем следующее. Добавляем в множество first(Х) множество first(Yi) до тех пор, пока first(Yi-1) содержит э, а first(Yi) не содержит э. При этом i изменяется от 0 до k. Это необходимо, так как если Yi-1 может отсутствовать, то необходимо выяснить, с чего будет начинаться вся последовательность в этом случае. \\ смотрим на все продукции и смотрим с какого нетерминала они начинаются

follow:
1. \\Для стартового нетерминала follow последовательность всегда будет <<EOF>>
2. Если есть правило А -> aBb, то в множество follow(В) добавляем множество first(b) без э. То есть, если есть правило, утверждающее, что за В следует b, то за нетеримналом будут следовать терминалы, с которых начинается последовательность b. \\ смотрим на продукции, в которых учавствует нетерминал и записываем first следующего после него терминала
3. Если есть правило А-> aB, то в множество follow(B) добавляется множество follow(A). То есть, если есть правило, утверждающее, что нетерминалом В заканчивается последовательность А, то за нетрминалом В будут следовать те же терминалы, что и за всей последовательностью А. \\ блять 
4. Если есть продукция А-> aBb и пустая последовательность принадлежит first(b), то в множество follow(B) добавляется множество follow(A). Если последовательность b не пуста, то терминалы, которые могут следовать за В уже найдены на шаге 1. Если же последовательность b пуста, то шаг 3 фактически сводится к шагу 2. \\ 
